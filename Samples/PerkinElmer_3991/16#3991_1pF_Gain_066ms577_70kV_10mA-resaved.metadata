[metadata]
width=2048
height=2048
qxrdVersion=Unknown
qtVersion=Unknown
dataType=6
dataTypeName=Pixel Gain Data
fileBase=16#3991_1pF_Gain_066ms577_70kV_10mA.his
fileName=F:/PerkinElmer_3991/16#3991_1pF_Gain_066ms577_70kV_10mA-resaved
title=16#3991_1pF_Gain_066ms577_70kV_10mA.his
readoutMode=0
exposureTime=0
summedExposures=0
imageNumber=0
phaseNumber=-1
nPhases=-1
dateTime=@Variant(\0\0\0\x10\0%\x81q\x3X\xed\xc0\xff)
dateString=2017.08.03 : 15:35:59.680
timeStamp=1501792559.68
hBinning=1
vBinning=1
cameraGain=0
triggered=0
userComment1=
userComment2=
userComment3=
userComment4=
imageSaved=1
normalization=@Variant(\0\0\0\x7f\0\0\0\xfQcepDoubleList\0\0\0\0\0)
normalization\size=0
extraInputs=@Variant(\0\0\0\x7f\0\0\0\xfQcepDoubleList\0\0\0\0\0)
extraInputs\size=0
used=true

[normalization]
size=0

[centerfinder]
centerX=0
centerY=0
centerStep=1
detectorXPixelSize=200
detectorYPixelSize=200
detectorDistance=1000
detectorDistanceStep=100
energy=20000
implementTilt=false
detectorTilt=0
detectorTiltStep=0.1
tiltPlaneRotation=90
tiltPlaneRotationStep=10
markedPoints=@Variant(\0\0\0\x7f\0\0\0\x16QxrdPowderPointVector\0\0\0\0\0)
markedPoints\size=0
fittedRings=@Variant(\0\0\0\x7f\0\0\0\x16QxrdPowderPointVector\0\0\0\0\0)
fittedRings\size=0
calibrantName=NAC
calibrantLattice=10.251437
calibrantLatticeLimit=5
calibrantSymmetry=1
calibrantDSpacings=@Variant(\0\0\0\x7f\0\0\0\x16QxrdPowderPointVector\0\0\0\0\0)
calibrantDSpacings\size=0
ringRadius=0
ringRadiusA=0
ringRadiusB=0
ringRotation=0
peakFitRadius=10
peakHeight=100
peakCenterX=0
peakCenterY=0
peakWidth=2
peakBackground=0
peakBackgroundX=0
peakBackgroundY=0
peakFitDebug=false
peakFitIterations=200
ringAngles=@Variant(\0\0\0\x7f\0\0\0\x11QcepDoubleVector\0\0\0\0\0)
ringAngles\size=0
ringAngleTolerance=0.1
powderFitOptions=0
ringIndex=0
subtractRingAverages=false
ringAverageDisplacement=0
fittedWidthMin=0.5
fittedWidthMax=3
fittedHeightMinRatio=0.25
fittedPositionMaxDistance=2

[integrator]
oversample=1
integrationStep=0.001
integrationNSteps=0
integrationMinimum=0
integrationMaximum=100000
integrationXUnits=0
enableGeometricCorrections=false
enablePolarizationCorrections=false
polarization=0.95
enableAbsorptionCorrections=false
attenuationLength=0
enableUserGeometry=0
userGeometryScript="/*\r\n  This file gives an example user geometry function.\r\n\r\n  The value of 'centering.enableUserGeometry' determines hoe the geometry\r\n  function will be called:\r\n\r\n  0:  No user geometry function\r\n  1:  Called with detector pixel coordinates as arguments\r\n\r\n  The function should return a radial distance value which represents\r\n  the bin number that the pixel should map into,  If you want a pixel to\r\n  be ignored you can return a NaN value.\r\n  */\r\n\r\nfunction userGeometry(i, j) {\r\n  /* this example implements an untilted detector, with hte\r\n    beam center at (1234,2076)\r\n    */\r\n\r\n  return Math.sqrt(Math.pow(i-1234,2) + Math.pow(j-2076,2));\r\n}\r\n"
userGeometryFunction=userGeometry
enableUserAbsorption=0
userAbsorptionScript="/*\r\n  This file contains some example user absorption functions.\r\n\r\n  The value of 'centering.enableUserAbsorption' determines how the absorption\r\n  function will be called:\r\n\r\n  0:   No user defined absorption\r\n  1:   Called with detector pixel coordinate as arguments (ignores tilt correction)\r\n  2:   Called with x,y displacement from beam center at detector plane (uses tilt correction)\r\n  3:   Called with r,chi as arguments (uses tilt correction)\r\n  4:   Called with q,chi as arguments (uses tilt correction)\r\n\r\n  The value returned by the function will be used to multiply the image intensity\r\n\r\n\r\n  */\r\n\r\nfunction userAbsorb1(i,j) {\r\n  /* As a function of pixel coordinates */\r\n  /* this example implements a 500 pixel radius circle, centered at (1234,2076) */\r\n\r\n  var rad = Math.sqrt(Math.pow(i-1234,2) + Math.pow(j-2076,2));\r\n\r\n  if (rad > 500) {\r\n    return 0;\r\n  } else {\r\n    return 1;\r\n  }\r\n}\r\n\r\nfunction userAbsorb2(x,y) {\r\n  /* As a function of x,y displacement from detector center */\r\n  /* this example implements a 50mm radius circle */\r\n\r\n  var rad = Math.sqrt(Math.pow(x,2) + Math.pow(y,2));\r\n\r\n  if (rad > 50) {\r\n    return 0;\r\n  } else {\r\n    return 1;\r\n  }\r\n}\r\n\r\nfunction userAbsorb3(r,chi) {\r\n  /* as a function of r,chi - again a 50mm circle */\r\n\r\n  if (r > 50) {\r\n    return 0;\r\n  } else {\r\n    return 1;\r\n  }\r\n}\r\n\r\nfunction userAbsorb4(q, chi) {\r\n  /* as a function of q,chi */\r\n\r\n  if (q > 0.1) {\r\n    return 0;\r\n  } else {\r\n    return 1;\r\n  }\r\n}\r\n"
userAbsorptionFunction=userAbsorb1
scalingFactor=1
